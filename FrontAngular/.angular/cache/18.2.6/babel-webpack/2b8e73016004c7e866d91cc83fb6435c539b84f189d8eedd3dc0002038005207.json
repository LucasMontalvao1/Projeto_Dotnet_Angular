{"ast":null,"code":"import _asyncToGenerator from \"C:/dev/Projeto_Dotnet_Angular/FrontAngular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, filter, firstValueFrom, Observable, share, Subject, take } from 'rxjs';\nimport { Client } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state.js';\n/**\r\n * This is the main Stomp Client.\r\n * Typically, you will create an instance of this to connect to the STOMP broker.\r\n *\r\n * This wraps an instance of [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\r\n * {@link Client}.\r\n *\r\n * The key difference is that it exposes operations as RxJS Observables.\r\n * For example, when a STOMP endpoint is subscribed it returns an Observable\r\n * that will stream all received messages.\r\n *\r\n * With exception to beforeConnect, functionality related to all callbacks in\r\n * [@stomp/stompjs Client]{@link Client}\r\n * is exposed as Observables/Subjects/BehaviorSubjects.\r\n *\r\n * RxStomp also tries to transparently handle connection failures.\r\n *\r\n * Part of `@stomp/rx-stomp`\r\n */\nexport class RxStomp {\n  /**\r\n   * Instance of actual\r\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\r\n   * {@link Client}.\r\n   *\r\n   * **Be careful in calling methods on it directly - you may get unintended consequences.**\r\n   */\n  get stompClient() {\n    return this._stompClient;\n  }\n  /**\r\n   * Constructor\r\n   *\r\n   * @param stompClient optionally inject the\r\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\r\n   * {@link Client} to wrap. If this is not provided, a client will\r\n   * be constructed internally.\r\n   */\n  constructor(stompClient) {\n    /**\r\n     * Internal array to hold locally queued messages when STOMP broker is not connected.\r\n     */\n    this._queuedMessages = [];\n    const client = stompClient ? stompClient : new Client();\n    this._stompClient = client;\n    const noOp = () => {};\n    // Before connect is no op by default\n    this._beforeConnect = noOp;\n    // Correlate errors is falsey op by default\n    this._correlateErrors = () => undefined;\n    // debug is no-op by default\n    this._debug = noOp;\n    // Initial state is CLOSED\n    this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n    this._connectedPre$ = this._connectionStatePre$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    }));\n    // Initial state is CLOSED\n    this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n    this.connected$ = this.connectionState$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    }));\n    // Setup sending queuedMessages\n    this.connected$.subscribe(() => {\n      this._sendQueuedMessages();\n    });\n    this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n    this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter(headers => {\n      return headers !== null;\n    }));\n    this.stompErrors$ = new Subject();\n    this.unhandledMessage$ = new Subject();\n    this.unhandledReceipts$ = new Subject();\n    this.unhandledFrame$ = new Subject();\n    this.webSocketErrors$ = new Subject();\n  }\n  /**\r\n   * Set configuration. This method may be called multiple times.\r\n   * Each call will add to the existing configuration.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```javascript\r\n   *        const rxStomp = new RxStomp();\r\n   *        rxStomp.configure({\r\n   *          brokerURL: 'ws://127.0.0.1:15674/ws',\r\n   *          connectHeaders: {\r\n   *            login: 'guest',\r\n   *            passcode: 'guest'\r\n   *          },\r\n   *          heartbeatIncoming: 0,\r\n   *          heartbeatOutgoing: 20000,\r\n   *          reconnectDelay: 200,\r\n   *          debug: (msg: string): void => {\r\n   *            console.log(new Date(), msg);\r\n   *          }\r\n   *        });\r\n   *        rxStomp.activate();\r\n   * ```\r\n   *\r\n   * Maps to: [Client#configure]{@link Client#configure}\r\n   */\n  configure(rxStompConfig) {\n    const stompConfig = Object.assign({}, rxStompConfig);\n    if (stompConfig.beforeConnect) {\n      this._beforeConnect = stompConfig.beforeConnect;\n      delete stompConfig.beforeConnect;\n    }\n    if (stompConfig.correlateErrors) {\n      this._correlateErrors = stompConfig.correlateErrors;\n      delete stompConfig.correlateErrors;\n    }\n    // RxStompConfig has subset of StompConfig fields\n    this._stompClient.configure(stompConfig);\n    if (stompConfig.debug) {\n      this._debug = stompConfig.debug;\n    }\n  }\n  /**\r\n   * Initiate the connection with the broker.\r\n   * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\r\n   * it will keep trying to reconnect.\r\n   *\r\n   * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\r\n   *\r\n   * Maps to: [Client#activate]{@link Client#activate}\r\n   */\n  activate() {\n    var _this = this;\n    this._stompClient.configure({\n      beforeConnect: function () {\n        var _ref = _asyncToGenerator(function* () {\n          _this._changeState(RxStompState.CONNECTING);\n          // Call handler\n          yield _this._beforeConnect(_this);\n        });\n        return function beforeConnect() {\n          return _ref.apply(this, arguments);\n        };\n      }(),\n      onConnect: frame => {\n        this._serverHeadersBehaviourSubject$.next(frame.headers);\n        // Indicate our connected state to observers\n        this._changeState(RxStompState.OPEN);\n      },\n      onStompError: frame => {\n        // Trigger the frame subject\n        this.stompErrors$.next(frame);\n      },\n      onWebSocketClose: () => {\n        this._changeState(RxStompState.CLOSED);\n      },\n      onUnhandledMessage: message => {\n        this.unhandledMessage$.next(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.unhandledReceipts$.next(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.unhandledFrame$.next(frame);\n      },\n      onWebSocketError: evt => {\n        this.webSocketErrors$.next(evt);\n      }\n    });\n    // Attempt connection\n    this._stompClient.activate();\n  }\n  /**\r\n   * Disconnect if connected and stop auto reconnect loop.\r\n   * Appropriate callbacks will be invoked if the underlying STOMP connection was connected.\r\n   *\r\n   * To reactivate, you can call [RxStomp#activate]{@link RxStomp#activate}.\r\n   *\r\n   * This call is async. It will resolve immediately if there is no underlying active websocket,\r\n   * otherwise, it will resolve after the underlying websocket is properly disposed of.\r\n   *\r\n   * Experimental: Since version 2.0.0, pass `force: true` to immediately discard the underlying connection.\r\n   * See [Client#deactivate]{@link Client#deactivate} for details.\r\n   *\r\n   * Maps to: [Client#deactivate]{@link Client#deactivate}\r\n   */\n  deactivate(options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2._changeState(RxStompState.CLOSING);\n      // The promise will be resolved immediately if there is no active connection\n      // otherwise, after it has successfully disconnected.\n      yield _this2._stompClient.deactivate(options);\n      _this2._changeState(RxStompState.CLOSED);\n    })();\n  }\n  /**\r\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\r\n   */\n  connected() {\n    return this.connectionState$.getValue() === RxStompState.OPEN;\n  }\n  /**\r\n   * If the client is active (connected or going to reconnect).\r\n   *\r\n   *  Maps to: [Client#active]{@link Client#active}\r\n   */\n  get active() {\n    return this.stompClient.active;\n  }\n  /**\r\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\r\n   * and naming of destinations.\r\n   *\r\n   * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\r\n   *\r\n   * `body` must be String.\r\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\r\n   *\r\n   * To send a binary message body, use binaryBody parameter. It should be a\r\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\r\n   * Sometimes brokers may not support binary frames out of the box.\r\n   * Please check your broker documentation.\r\n   *\r\n   * The ` content-length` header is automatically added to the STOMP Frame sent to the broker.\r\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\r\n   * For binary messages, `content-length` header is always added.\r\n   *\r\n   * Caution: The broker will, most likely, report an error and disconnect if the message body has NULL octet(s)\r\n   * and `content-length` header is missing.\r\n   *\r\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\r\n   * publish queued messages as soon as the broker gets connected.\r\n   * If you do not want that behavior,\r\n   * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\r\n   * in the parameters.\r\n   * When `false`, this function will raise an error if a message could not be sent immediately.\r\n   *\r\n   * Maps to: [Client#publish]{@link Client#publish}\r\n   *\r\n   * See: {@link IRxStompPublishParams} and {@link IPublishParams}\r\n   *\r\n   * ```javascript\r\n   *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\r\n   *\r\n   *        // Only destination is mandatory parameter\r\n   *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\r\n   *\r\n   *        // Skip content-length header in the frame to the broker\r\n   *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\r\n   *\r\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\r\n   *        // setting content-type header is not mandatory, however a good practice\r\n   *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\r\n   *                         headers: {'content-type': 'application/octet-stream'}});\r\n   * ```\r\n   */\n  publish(parameters) {\n    // retry behaviour is defaulted to true\n    const shouldRetry = parameters.retryIfDisconnected == null ? true : parameters.retryIfDisconnected;\n    if (this.connected()) {\n      this._stompClient.publish(parameters);\n    } else if (shouldRetry) {\n      this._debug(`Not connected, queueing`);\n      this._queuedMessages.push(parameters);\n    } else {\n      throw new Error('Cannot publish while broker is not connected');\n    }\n  }\n  /** It will send queued messages. */\n  _sendQueuedMessages() {\n    const queuedMessages = this._queuedMessages;\n    this._queuedMessages = [];\n    if (queuedMessages.length === 0) {\n      return;\n    }\n    this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n    for (const queuedMessage of queuedMessages) {\n      this._debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage);\n    }\n  }\n  watch(opts, headers = {}) {\n    const defaults = {\n      subHeaders: {},\n      unsubHeaders: {},\n      subscribeOnlyOnce: false\n    };\n    let params;\n    if (typeof opts === 'string') {\n      params = Object.assign({}, defaults, {\n        destination: opts,\n        subHeaders: headers\n      });\n    } else {\n      params = Object.assign({}, defaults, opts);\n    }\n    /* Well, the logic is complicated but works beautifully. RxJS is indeed wonderful.\r\n     *\r\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not, it should\r\n     * subscribe when it gets next connected. Further, it should re-establish the subscription whenever Stomp\r\n     * successfully reconnects.\r\n     *\r\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\r\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\r\n     *\r\n     * The observable that we return to the caller remains the same across all reconnects, so no special handling needed at\r\n     * the message subscriber.\r\n     */\n    this._debug(`Request to subscribe ${params.destination}`);\n    const coldObservable = Observable.create(messages => {\n      /*\r\n       * These variables will be used as part of the closure and work their magic during unsubscribe\r\n       */\n      let stompSubscription; // Stomp\n      let stompConnectedSubscription; // RxJS\n      let connectedPre$ = this._connectedPre$;\n      if (params.subscribeOnlyOnce) {\n        connectedPre$ = connectedPre$.pipe(take(1));\n      }\n      const stompErrorsSubscription = this.stompErrors$.subscribe(error => {\n        const correlatedDestination = this._correlateErrors(error);\n        if (correlatedDestination === params.destination) {\n          messages.error(error);\n        }\n      });\n      stompConnectedSubscription = connectedPre$.subscribe(() => {\n        this._debug(`Will subscribe to ${params.destination}`);\n        let subHeaders = params.subHeaders;\n        if (typeof subHeaders === 'function') {\n          subHeaders = subHeaders();\n        }\n        stompSubscription = this._stompClient.subscribe(params.destination, message => {\n          messages.next(message);\n        }, subHeaders);\n      });\n      return () => {\n        /* cleanup function, it will be called when no subscribers are left */\n        this._debug(`Stop watching connection state (for ${params.destination})`);\n        stompConnectedSubscription.unsubscribe();\n        stompErrorsSubscription.unsubscribe();\n        if (this.connected()) {\n          this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n          let unsubHeaders = params.unsubHeaders;\n          if (typeof unsubHeaders === 'function') {\n            unsubHeaders = unsubHeaders();\n          }\n          stompSubscription.unsubscribe(unsubHeaders);\n        } else {\n          this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n        }\n      };\n    });\n    /**\r\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\r\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\r\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\r\n     */\n    return coldObservable.pipe(share());\n  }\n  /**\r\n   * **Deprecated** Please use {@link asyncReceipt}.\r\n   */\n  watchForReceipt(receiptId, callback) {\n    this._stompClient.watchForReceipt(receiptId, callback);\n  }\n  /**\r\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\r\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\r\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically, a sequence, a UUID, a\r\n   * random number or a combination may be used.\r\n   *\r\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\r\n   * The operation needs to be matched based on the value of the receipt-id.\r\n   *\r\n   * This method allows watching for a receipt and invoking the callback\r\n   * when the corresponding receipt has been received.\r\n   *\r\n   * The promise will yield the actual {@link IFrame}.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   *        // Publishing with acknowledgement\r\n   *        let receiptId = randomText();\r\n   *\r\n   *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\r\n   *        await rxStomp.asyncReceipt(receiptId);; // it yields the actual Frame\r\n   * ```\r\n   *\r\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\r\n   */\n  asyncReceipt(receiptId) {\n    return firstValueFrom(this.unhandledReceipts$.pipe(filter(frame => frame.headers['receipt-id'] === receiptId)));\n  }\n  _changeState(state) {\n    this._connectionStatePre$.next(state);\n    this.connectionState$.next(state);\n  }\n}\n//# sourceMappingURL=rx-stomp.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}