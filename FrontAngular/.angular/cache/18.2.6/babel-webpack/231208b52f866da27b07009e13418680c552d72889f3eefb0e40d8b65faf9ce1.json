{"ast":null,"code":"/**\r\n * @internal\r\n */\nconst NULL = 0;\n/**\r\n * @internal\r\n */\nconst LF = 10;\n/**\r\n * @internal\r\n */\nconst CR = 13;\n/**\r\n * @internal\r\n */\nconst COLON = 58;\n/**\r\n * This is an evented, rec descent parser.\r\n * A stream of Octets can be passed and whenever it recognizes\r\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\r\n *\r\n * All incoming Octets are fed into _onByte function.\r\n * Depending on current state the _onByte function keeps changing.\r\n * Depending on the state it keeps accumulating into _token and _results.\r\n * State is indicated by current value of _onByte, all states are named as _collect.\r\n *\r\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\r\n * imply that all lengths are considered in bytes (instead of string lengths).\r\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\r\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\r\n *\r\n * There is no peek function on the incoming data.\r\n * When a state change occurs based on an Octet without consuming the Octet,\r\n * the Octet, after state change, is fed again (_reinjectByte).\r\n * This became possible as the state change can be determined by inspecting just one Octet.\r\n *\r\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\r\n * otherwise it is determined by NULL terminator.\r\n *\r\n * Following the standards, the command and headers are converted to Strings\r\n * and the body is returned as Octets.\r\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\r\n *\r\n * This parser does not use Regular Expressions as that can only operate on Strings.\r\n *\r\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\r\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\r\n * is pushed.\r\n *\r\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\r\n * (which is protocol version specific), and convert body to text.\r\n *\r\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\nexport class Parser {\n  constructor(onFrame, onIncomingPing) {\n    this.onFrame = onFrame;\n    this.onIncomingPing = onIncomingPing;\n    this._encoder = new TextEncoder();\n    this._decoder = new TextDecoder();\n    this._token = [];\n    this._initState();\n  }\n  parseChunk(segment, appendMissingNULLonIncoming = false) {\n    let chunk;\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    }\n    // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    }\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n  _collectFrame(byte) {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n  _collectCommand(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectHeaders(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n  _reinjectByte(byte) {\n    this._onByte(byte);\n  }\n  _collectHeaderKey(byte) {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectHeaderValue(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(header => {\n      return header[0] === 'content-length';\n    })[0];\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n  _collectBodyNullTerminated(byte) {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectBodyFixedSize(byte) {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if (this._bodyBytesRemaining-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n    }\n    this._initState();\n  }\n  // Rec Descent Parser helpers\n  _consumeByte(byte) {\n    this._token.push(byte);\n  }\n  _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n  _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n  _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined\n    };\n    this._token = [];\n    this._headerKey = undefined;\n    this._onByte = this._collectFrame;\n  }\n}\n//# sourceMappingURL=parser.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}